# Queue


* Очередь описывается классом Queue
* метод Queue#push позволяет добавлять в очередь объекты класса Task, которые характеризуются временем до которого его нужно выполнить(finish_time) и описанием(description)
```
task = Task.new finish_time: Time.parse('2012-06-25 10:00'), description: 'foo'
```
## Queue#get_task(finish_time) 
* возвращает объект класса Task.
* finish_time - время, к которому задание должно быть выполнено, объект класса Time
* один вызов - один объект
* после вызова Queue#get_task - задание удаляется из очереди
* если в очереди есть просроченные задания - сначала нужно вернуть их
* просроченные задания возвращаются по очереди, где сначала идут самые "просроченные" задания
* если в очереди нет "просроченных" заданий, вернуть те, которые должны быть выполнены точно в переданное время.
* Если нет "просроченных" или таких заданий, которые должны быть выполнены точно в переданное время - вернуть nil

##Queue#pop
* возвращает объект класса Task.
* один вызов - один объект
* после вызова Queue#pop - задание удаляется из очереди
* если в очереди есть просроченные задания - нужно вернуть их
* задания возвращаются по очереди, где сначала идут самые "просроченные" задания
* если нет "просроченных" заданий - вернуть nil

## Дополнтельно
* eсли задание показалось Вам очень простым, реализуйте эту очередь так, что бы она была threadsafe.
* eсли всё ещё слишком просто - реализуйте эту очередь так, что бы сообщения сохранялись в redis, и методы pop, push, get_task выполнялись атомарно.

## Обязательные требования:
* полное покрытие тестами
* понятный, документированный, легко читаемый код
* разработка через VCS git
* размещение кода на github.com
* атомарные commit-ы в git с понятным commit message
* должно работать под всеми версиями ruby (1.8.7 - 1.9.3)
* код проекта должен использовать bundler (Gemfile.lock добавить в репозиторий)
* для выполнения этого задания НЕ НУЖНО писать rails приложение

